{-
    ÐšÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾Ð½Ñ‹, Ñ‚Ð¾Ð»ÑŒÐºÐ¾ 1 Ñ‚Ð¾Ð½ (Ð²ÑÐµ Ñ‡Ñ‚Ð¾ Ð¼ÐµÐ½ÑŒÑˆÐµ Ð¸ Ð±Ð¾Ð»ÑŒÑˆÐµ â€” Ð½Ðµ ÑƒÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÑ‚, Ð¶ÐµÑ‚Ð¾Ð½Ñ‹ Ñ‚Ð¾Ð¶Ðµ, Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¾ÑÑ‚Ð°Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ð° ÐºÐ¾ÑˆÐµÐ»ÑŒÐºÐµ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ð°). 
    ÐšÐ°Ðº Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð°Ð±Ð¸Ñ€Ð°ÐµÑ‚ÑÑ 10 Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ñ… ÑƒÑÐ»Ð¾Ð²Ð¸ÑÐ¼ â€” Ð¾Ð½ Ð´ÐµÐ»Ð°ÐµÑ‚ Ñ€Ð°Ð½Ð´Ð¾Ð¼Ð½Ñ‹Ð¹ Ð²Ñ‹Ð±Ð¾Ñ€ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¸Ð· ÐºÐ¾ÑˆÐµÐ»ÑŒÐºÐ¾Ð² Ð² ÑÑ‚Ð¸Ñ… 10 Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸ÑÑ… Ð¸ Ð²Ñ‹Ð´Ð°ÐµÑ‚ ÐµÐ¼Ñƒ 70% Ð±Ð°Ð½ÐºÐ°. ÐžÑÑ‚Ð°Ð²ÑˆÐ¸ÐµÑÑ 30% â€” Ð¾Ñ‚ÑÑ‹Ð»Ð°ÐµÑ‚ Ð½Ð° Ð°Ð´Ñ€ÐµÑ Ð¥. 

    ÐŸÐ¾ÑÐ»Ðµ â€” Ð½Ð°Ñ‡Ð¸Ð½Ð°ÐµÑ‚ÑÑ Ð½Ð¾Ð²Ñ‹Ð¹ Ñ†Ð¸ÐºÐ» Ð³Ð´Ðµ Ð½Ð° 10Ð¹ Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¸ Ð²ÑÐµ Ñ‚Ð¾Ð¶Ðµ ÑÐ°Ð¼Ð¾Ðµ Ð¸ Ð¿Ð¾Ñ‚Ð¾Ð¼ Ð¾Ð¿ÑÑ‚ÑŒ Ð¿Ð¾-Ð½Ð¾Ð²Ð¾Ð¹.

    Ð’ÐµÑ€Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ â€” 1 ÐºÐ¾ÑˆÐµÐ»ÐµÐº = 1 ÑƒÑ‡Ð°ÑÑ‚Ð¸Ðµ Ð² Ñ†Ð¸ÐºÐ»Ðµ, ÐµÑÐ»Ð¸ ÐºÐ¸Ð½ÑƒÑ‚ÑŒ 2Ð¹ Ñ€Ð°Ð· Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¸ Ñ‚Ð¾Ð³Ð¾ Ð¶Ðµ ÐºÐ¾ÑˆÐµÐ»ÑŒÐºÐ° Ð² Ñ€Ð°Ð¼ÐºÐ°Ñ… Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ†Ð¸ÐºÐ»Ð°, Ñ‚Ð¾ ÑÑ‚Ð° Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ñ Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÑÐµÑ‚ÑÑ Ð¸ Ñ‚Ð¾Ð½Ñ‹ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÑŽÑ‚ÑÑ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÐµÐ»ÑŽ.

    ÐšÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð»ÑŽÐ±Ñ‹Ðµ Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð»ÐµÐ½Ð¸Ñ (Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ðµ Ð·Ð°Ð¿ÑƒÑ‚Ð°Ñ‚ÑŒÑÑ/Ð½Ðµ Ð·Ð°ÑÐºÐ°Ð¼Ð¸Ð»Ð¸). ÐÐµÐ²Ð°Ð¶Ð½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑÑ‚ ÐµÐ¼Ñƒ Ð½Ñ„Ñ‚, Ñ‚Ð¾ÐºÐµÐ½Ñ‹, usdt Ð¸Ð»Ð¸ Ñ‡Ñ‚Ð¾-Ñ‚Ð¾ ÐµÑ‰Ðµ â€” Ð²ÑÐµ, Ñ‡Ñ‚Ð¾ Ð½Ðµ Ñ€Ð°Ð²Ð½Ð¾ ÑÑ‚Ð°Ð²ÐºÐµ = Ð´Ð»Ñ Ð½ÐµÐ³Ð¾ Ð½ÐµÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚

    ÐžÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸:
    1. ÐÐ°ÑÑ‚Ñ€Ð°Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ð² ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ðµ ÐºÐ¾ÑˆÐµÐ»ÐµÐº ÐºÑƒÐ´Ð° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ÑÑ 30% Ð±Ð°Ð½ÐºÐ°
    2. Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð»ÐµÐ³ÐºÐ¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð²ÐµÐ»Ð¸Ñ‡Ð¸Ð½Ñƒ ÑÑ‚Ð°Ð²ÐºÐ¸ Ð² ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ðµ (Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ñ Ð¼Ð¾Ð³ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ð¿Ð¾Ñ‚Ð¾Ð¼ Ñ‚Ð°ÐºÐ¾Ð¹ Ð¶Ðµ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚, Ð½Ð¾ Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ ÑÐ¾ ÑÑ‚Ð°Ð²ÐºÐ¾Ð¹ 5 TON Ð¸ Ñ‚Ð¾Ð³Ð´Ð° Ð±Ð°Ð½Ðº Ð±ÑƒÐ´ÐµÑ‚ 50 TON)
    3. ÐŸÑ€Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ Ð±Ð°Ð½ÐºÐ° Ð¿Ð¾Ð±ÐµÐ´Ð¸Ñ‚ÐµÐ»ÑŽ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ. (ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸Ð¹)
    4. ÐšÐ¾Ð¼Ð¸ÑÑÐ¸Ð¸ Ð¿Ñ€Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ Ð±Ð°Ð½ÐºÐ° Ð¸ Ð¾ÑÑ‚Ð°Ð²ÑˆÐ¸Ñ…ÑÑ 30% Ð½Ð° Ð°Ð´Ñ€ÐµÑ Ð¥Ð¥ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð²Ñ‹Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒÑÑ Ñ ÑÑƒÐ¼Ð¼Ñ‹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¾Ðº(Ð° Ð½Ðµ Ñ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ñ‹Ñ… ÑÑ€ÐµÐ´ÑÑ‚Ð² Ð½Ð° ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ðµ)
-}

#pragma version >=0.4.0;

#include "imports/stdlib.fc";
#include "imports/utils.fc";
#include "imports/op-codes.fc";
#include "imports/constants.fc";

global int started?;
global slice storage::admin_address;
global slice storage::bank_wallet_address;
global cell storage::address_list;
global int storage::cycle_length;
global int storage::bet_amount;
global int storage::address_count;
global int storage::bank_total_cash;

() load_data() impure inline {                              ;; 1 + 267 + 267 + 32 + 124 + 32 + 124 = 847b
    var ds = get_data().begin_parse();

    started? = ds~load_int(1);
    storage::admin_address = ds~load_msg_addr();    
    storage::bank_wallet_address = ds~load_msg_addr();
    storage::address_list = ds~load_dict();
    storage::cycle_length = ds~load_uint(32);
    storage::bet_amount = ds~load_coins();
    storage::address_count = ds~load_uint(32);
    storage::bank_total_cash = ds~load_coins();    
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_int(started?, 1)
            .store_slice(storage::admin_address)
            .store_slice(storage::bank_wallet_address)
            .store_dict(storage::address_list)
            .store_uint(storage::cycle_length, 32)
            .store_coins(storage::bet_amount)
            .store_uint(storage::address_count, 32)
            .store_coins(storage::bank_total_cash)
        .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if(flags & 1) {
        return();
    }

    slice sender_address = cs~load_msg_addr();

    load_data();

    try {
        if(in_msg_body.slice_empty?()) {
            throw_unless(err::wrong_bet_amount, msg_value == storage::bet_amount);
            (_, int found) = storage::address_list.dict_get?(267, sender_address);
            
            if(found) {
                throw(err::user_already_in_list);
            }
            else {
                if(storage::address_count < storage::cycle_length) {
                    started? = true;
                    force_same_workchain(sender_address);
                    storage::address_list~dict_set_builder(267, sender_address, begin_cell().store_uint(storage::address_count, 32));
                    storage::address_count += 1;
                    storage::bank_total_cash += msg_value;
                    send_message_with_comment(0x10, sender_address, gas::info, notify::bet_accepted, 1);
                    save_data();
                }

                if(storage::address_count == storage::cycle_length) {
                    randomize_lt();
                    int random_number = rand(storage::cycle_length - 1);
                    do {
                       (slice address, slice value, int f?) = storage::address_list~dict::delete_get_min(267);
                       int user_number = value.preload_uint(32);

                       if(user_number == random_number) {
                            raw_reserve(gas::min_for_storage, 0);

                            int bank_percent = muldiv(storage::bank_total_cash, const::thirty_percent, const::percent_divisor);
                            send_message_with_comment(0x10, storage::bank_wallet_address, bank_percent, notify::bank_fee, 1);

                            int user_reward = muldiv(storage::bank_total_cash, const::seventy_percent, const::percent_divisor);
                            send_message_with_comment(0x10, address, user_reward, notify::winner, 1);

                            storage::address_count = 0;
                            storage::bank_total_cash = 0;
                            storage::address_list = new_dict();
                            started? = false;
                            
                            save_data();
                            return();
                       }
                       storage::address_count -= 1;
                    }
                    until((~ f?) | (storage::address_count == 0));

                    throw(err::something_went_wrong);
                }

                return();
            }
        }
    }
    catch (_, n) {
        send_cell_message(sender_address, 0, begin_cell().store_uint(0, 32).build_exit_code(n).end_cell(), 64);
        return();
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body.slice_bits() >= 64 ? in_msg_body~load_uint(64) : 0;

    ;; Admin only
    try {
        throw_unless(err::unauthorized_access, equal_slices(sender_address, storage::admin_address));

        if((op == op::deploy) & (started? == false)) {
            throw_unless(err::wrong_deploy_amount, msg_value >= gas::deploy_value);
            return();
        }

        if(op == 0) { ;; if already deployed contract needs some ton (just in case)
            int comment = string_hash(in_msg_body);
            if(comment == "Top up"H) {
                send_message_with_comment(0x10, sender_address, 1000000, notify::top_up, 1);
                return();
            } 
            else {
                throw(err::unknown_action);
            }
        }
        if(op == op::change_bet) {
            throw_unless(err::out_of_gas, msg_value >= gas::admin);
            throw_if(err::lottery_started, started?);

            int new_bet = in_msg_body~load_coins();

            if(new_bet > 0) {
                storage::bet_amount = new_bet;
                save_data();
                send_cell_message(sender_address, 0, begin_cell().store_uint(0, 32).store_slice("Bet changed to ").store_str_float(new_bet, const::number_divisor).store_slice(" ðŸ’Ž").end_cell(), 64);
                return();
            } else { throw(err::wrong_new_bet); }
        }

        if(op == op::change_cycle_length) {
            throw_unless(err::out_of_gas, msg_value >= gas::admin);
            throw_if(err::lottery_started, started?);

            int new_cycle_length = in_msg_body~load_uint(32);

            if(new_cycle_length > 0) {
                storage::cycle_length = new_cycle_length;
                save_data();
                send_cell_message(sender_address, 0, begin_cell().store_uint(0, 32).store_slice("Cycle length changed to ").store_number10(new_cycle_length).store_slice(" !").end_cell(), 64);
                return();
            } else { throw(err::wrong_cycle_length); }
        }

        if(op == op::change_bank_wallet_address) {
        throw_unless(err::out_of_gas, msg_value >= gas::admin);
        slice new_bank_wallet_address = in_msg_body~load_msg_addr();
        force_same_workchain(new_bank_wallet_address);
        
        if(new_bank_wallet_address.preload_uint(2) == 2) {
            storage::bank_wallet_address = new_bank_wallet_address;
            save_data();
            send_cell_message(sender_address, 0, begin_cell().store_uint(0, 32).store_slice("Bank wallet address changed!").end_cell(), 64);
            return();
        } else { throw(err::wrong_addr_std); }
    }

        if(op == op::withdraw_jettons) {
            throw_unless(err::out_of_gas, msg_value >= gas::jetton_transfer);

            slice jetton_wallet_address = in_msg_body~load_msg_addr();
            int jetton_amount = in_msg_body~load_coins();

            if((in_msg_body.slice_bits() > 0) & (in_msg_body.slice_bits() == 267)) {
                slice to_address = in_msg_body~load_msg_addr();
                force_same_workchain(to_address);
                send_jettons(query_id, jetton_amount, to_address, sender_address, jetton_wallet_address, 0, 64, 1, null());
            }
            else {
                send_jettons(query_id, jetton_amount, const::zero_address, sender_address, jetton_wallet_address, 0, 64, 1, null());
            }

            return();
        }

        if(op == op::withdraw_nft) {
            throw_unless(err::out_of_gas, msg_value >= gas::nft_transfer);

            slice nft_address = in_msg_body~load_msg_addr();

            if((in_msg_body.slice_bits() > 0) & (in_msg_body.slice_bits() == 267)) {
                slice to_address = in_msg_body~load_msg_addr();
                force_same_workchain(to_address);

                send_nft(query_id, nft_address, to_address, 0, 64);
            }
            else {
                send_nft(query_id, nft_address, const::zero_address, 0, 64);
            }
            
            return();
        }

        throw(unknown_operation);
    }
    catch (_, n) {
        send_cell_message(sender_address, 0, begin_cell().store_uint(0, 32).build_exit_code(n).end_cell(), 64);
        return();
    }    
}

;; GET

(slice, slice, cell, int, int, int, int) get_lottery_data() method_id {
    load_data();

    return(
        storage::admin_address,
        storage::bank_wallet_address,
        storage::address_list,
        storage::cycle_length,
        storage::bet_amount,
        storage::address_count,
        storage::bank_total_cash
    );
}

int get_lottery_status() method_id { ;; 0 = lottery not started ;; -1 = lottery started
    load_data();

    return started?;
}
